---
title: "Technologies for Big Data Analytics"
format:
  html:
    code-fold: true
author-title: "Antonis Prodromou"
---

# Εργασία 1 - Threads and Processes
## Υποερώτημα 2

**Όνομα:** Αντώνης Προδρόμου

**Ημερομηνία:** 23 Νοεμβρίου 2025

---

## Περιγραφή Λύσης

Για την επίλυση του προβλήματος, ακολουθούμε την αρχή της Μοναδικής Αρμοδιότητας, δηλαδή όλες οι κλάσεις και οι λογισμικές μονάδες (modules) να έχουν μόνο μια, ξεκάθαρα ορισμένη αρομοδιότητα. Επομένως δημιουργούμε τις παρακάτω 6 κλάσεις, σε δύο επίπεδα (ανώτερου επιπέδου και ένθετες):

### Κλάση Ανώτερου Επιπέδου

**ProducerConsumerMain**

Αυτή είναι η κύρια κλάση από την οποία παίρνει το όνομά του το αρχείο (ProducerConsumerMain.java). Είναι public, δηλαδή μπορεί να χρησιμοποιηθεί από άλλα αντικείμενα και είναι ορατή από παντού. Περιέχει τη μέθοδο `main()` - το σημείο εισόδου του προγράμματός μας.

### Εσωτερικές Κλάσεις
* **Disease** - τοπική εσωτερική κλάση (ορίζεται εντός της μεθόδου `main()`).
    Υλοποιεί το `Runnable`, αναπαριστώντας το νήμα παραγωγού (*producer*).
* **Hospital** - τοπική εσωτερική κλάση (επίσης εντός της `main()`).
    Υλοποιεί το `Runnable`, αναπαριστώντας το νήμα καταναλωτή (*consumer*).
* **Registry** - στατική ένθετη κλάση (ορίζεται σε επίπεδο κλάσης).
    Διατηρεί αρχείο καταγραφής των δεδομένων του νοσοκομείου και της κοινόχρηστης κατάστασης (*shared state*).
* **DiseaseGeneration** - στατική ένθετη κλάση.
    Διαχειρίζεται τη λογική παραγωγής (δημιουργία νέων κρουσμάτων).
* **DiseaseHealing** - στατική ένθετη κλάση.
    Διαχειρίζεται τη λογική κατανάλωσης (θεραπεία και εξιτήρια κρουσμάτων).

Υπάρχει επίσης μια εξωτερική εξάρτηση (dependency) με όνομα `IterationLog`, ορισμένη σε ξεχωριστό αρχείο, η οποία χρησιμοποιείται για την καταγραφή των αποτελεσμάτων μας.

---

### Ενότητες (Modules)

Οι λογισμικές μονάδες διακρίνονται στις εξής:

| Ενότητα | Σκοπός |
| :--- | :--- |
| **DiseaseGeneration** | Ενσωματώνει όλη τη λογική παραγωγής (δημιουργία νέων κρουσμάτων). |
| **DiseaseHealing** | Ενσωματώνει όλη τη λογική θεραπείας (εξιτήρια ασθενών). |
| **Registry** | Κεντρική ενότητα διαχείρισης κατάστασης. Κοινή μεταξύ των νημάτων. |
| **IterationLog (εξωτερική)** | Ενότητα καταγραφής δεδομένων / *logging*. |

Αυτές είναι επαναχρησιμοποιήσιμες, λογικά απομονωμένες και θα μπορούσαν να τοποθετηθούν σε δικά τους αρχεία χωρίς να χαθεί η λειτουργικότητα.

---

### Παράμετροι

Οι παράμετροι του προγράμματος ορίζονται - σύμφωνα και με την εκφώνηση της άσκησης - με static final, γιατί είναι παράμετροι του μοντέλου και όχι καταγραφής, άρα δεν ενημερώνονται κατά την εκτέλεσή του.

----

### Multi-threading

Εφόσον έχω δύο threads που εκτελούν τις διεργασίες μου, ορίζω τις συναρτήσεις παραγωγής και κατανάλωσης με τον τύπο synchronized. Αυτή η μέθοδος διασφαλίζει πως μόνο ένα thread μπορεί να εκτελεί ανά οποιαδήποτε στιγμή αλλαγές πάνω σε ένα στιγμιότυπο (instance) ενός αντικειμένου, αποφεύγοντας έτσι ένα race condition. Εσωτερικά, η Java το επιτυγχάνει αυτό χρησιμοποιώντας ένα monitor lock, κλειδώνοντας κάθε φορά το registry:
```{java}
        public synchronized void produce() throws InterruptedException {
        ...
            synchronized (registry) {
            ...
                }
```

---

### Καταγραφές

Για την καταγραφή της λειτουργίας του προγράμματος και των αποτελεσμάτων του προγράμματος (monitoring), χρησιμοποιούμε μια σειρά από μεταβλητές, οι οποίες:

* Ορίζονται στην κλάση Registry, που αποτελεί κατά μια έννοια τον πυρήνα αποθήκευσής τους.
* Καταγράφουν τα αποτελέσματα ανά επανάληψη (iteration) μέσα στις μεθόδους `DiseaseGeneration.produce()` και `DiseaseHealing.heal()`.
* Αποθηκεύονται στην κλάση IterationLog (εξωτερική κλάση).

Οι μεταβλητές αυτές δίνονται στον παρακάτω πίνακα:

| Μεταβλητή | Σκοπός | Ενημερώνεται από |
| :--- | :--- | :--- |
| **incomingPatients** | Αριθμός νέων ασθενών που δημιουργήθηκαν σε αυτήν την επανάληψη. | Producer (`produce()`) |
| **patientsBeingTreated** | Αριθμός ασθενών που νοσηλεύονται αυτήν τη στιγμή. | Producer + Consumer |
| **patientsRejected** | Ασθενείς που απορρίφθηκαν επειδή το νοσοκομείο ήταν πλήρες. | Producer |
| **patientsAdmitted** | Ασθενείς που έγιναν δεκτοί και εισήχθησαν για θεραπεία. | Producer |
| **totalSickPatients** | Συνολικό άθροισμα όλων των περιστατικών που έχουν δημιουργηθεί ποτέ. | Producer |
| **healedPatients** | Ασθενείς που θεραπεύτηκαν στον τρέχοντα κύκλο θεραπείας. | Consumer |
| **totalPatientsHealed** | Συνολικός αριθμός ασθενών που έχουν θεραπευτεί μέχρι στιγμής. | Consumer |
| **totalPatientsRejected** | Συνολικός αριθμός ασθενών που έχουν απορριφθεί μέχρι στιγμής. | Producer |
| **generationIterations** | Πόσες φορές έχει εκτελεστεί ο βρόχος του παραγωγού (producer). | Producer |
| **healingIterations** | Πόσες φορές έχει εκτελεστεί ο βρόχος του καταναλωτή (consumer). | Consumer |
| **totalsLog** | Μια λίστα που αποθηκεύει λεπτομερή αρχεία καταγραφής για κάθε επανάληψη (δημιουργία και θεραπεία). | Και οι δύο |

---

###  Τερματισμός λειτουργίας

Στη λειτουργία των thread επιλέχθηκε όταν ολοκληρώνει τις επαναλήψεις του το ένα thread, η μεταβλητή raceFinished να αλλάζει από False σε True, ειδοποιώντας το δεύτερο thread να σταματήσει την λειτουργία του. Χρησιμοποιήσαμε για τον σκοπό αυτό μεταβλητή τύπου `AtomicBoolean`, η οποία διασφαλίζει πως η μεταβλητή raceFinished μπορεί να ενημερωθεί μόνο από ένα thread ανά φορά, δηλαδή με τρόπο ατομικό (atomic), που αποτρέπει ένα race condition.

---

## Αποτελέσματα

Από τα αποτελέσματα που δίνονται στον παρακάτω πίνακα παρατηρούμε πως:

* Οι επαναλήψεις του thread generation αυξάνονται ανά δευτερόλεπτο, εκτός από τις περιπτώσεις όπου έχουμε φτάσει το system capacity, οπότε το thread μπαίνει σε sleep mode (`wait()`), έως ότου το ξυπνήσει μέσω του `notify()` το healing thread, π.χ. στις επαναλήψεις του Generation με αριθμό 9, 11, και 15. Για αυτόν τον λόγο, παρότι η παραγωγή και η κατανάλωση έχουν περίοδους 1 και 5 δευτερόλεπτα αντίστοιχα, οι τελικές επαναλήψεις είναι 30 και 16 (στήλες 1 και 2) και όχι με αναλογία 5:1.

* Καταγράφονται σωστά οι συνολικοί ασθενείς (106), 49 εκ των οποίων θεραπεύονται, 37 δεν βρίσκουν θέση και 20 νοσηλεύονται όταν σταματάνε οι επαναλήψεις.

---

### Παρουσίαση αποτελεσμάτων

Για την παρουσίαση των αποτελεσμάτων, εξάγω τη λίστα IterationLog σε csv. Στη συνέχεια το εισάγω σε Quarto notebook και οπτικοποιώ τα αποτελέσματα χρησιμοποιώντας τις βιβλιοθήκες pandas και matplotlib της python.


```{python}
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv('producer_consumer_results_30_1000.csv')
df.style.hide(axis="index")
```

```{python}
# Set style for better-looking plots
sns.set_style("whitegrid")

# Load the data
df = pd.read_csv('producer_consumer_results_30_1000.csv')

# Create a figure with multiple subplots
fig, axes = plt.subplots(3, 1, figsize=(8, 14))
fig.suptitle('Hospital Patient Management Analysis\n', fontsize=16, fontweight='bold')

# 1. Patients Over Time
ax1 = axes[0]
ax1.plot(df['GenerationIter'], df['PatientsBeingTreated'], 
         marker='o', label='Patients Being Treated', linewidth=2)
ax1.plot(df['GenerationIter'], df['TotalSickPatients'], 
         marker='s', label='Total Sick Patients', linewidth=2, alpha=0.7)
ax1.set_xlabel('Generation Iteration')
ax1.set_ylabel('Number of Patients')
ax1.set_title('Patient Load Over Time')
ax1.legend()
ax1.grid(True, alpha=0.3)

# 3. Cumulative Healing Progress
ax3 = axes[1]
ax3.plot(df['GenerationIter'], df['TotalPatientsHealed'], 
         marker='o', color='green', linewidth=2, label='Total Healed')
ax3.plot(df['GenerationIter'], df['TotalPatientsRejected'], 
         marker='x', color='red', linewidth=2, label='Total Rejected')
ax3.fill_between(df['GenerationIter'], df['TotalPatientsHealed'], 
                 alpha=0.3, color='green')
ax3.fill_between(df['GenerationIter'], df['TotalPatientsRejected'], 
                 alpha=0.3, color='red')
ax3.set_xlabel('Generation Iteration')
ax3.set_ylabel('Cumulative Count')
ax3.set_title('Cumulative Patients Healed vs Rejected')
ax3.legend()
ax3.grid(True, alpha=0.3)

# 6. Hospital Capacity Utilization
ax6 = axes[2]
ax6.plot(df['GenerationIter'], df['PatientsBeingTreated'], 
         marker='o', linewidth=2, color='purple')
ax6.axhline(y=20, color='red', linestyle='--', linewidth=2, 
           label='Capacity Limit (20)', alpha=0.7)
ax6.fill_between(df['GenerationIter'], 0, df['PatientsBeingTreated'], 
                 alpha=0.3, color='purple')
ax6.set_xlabel('Generation Iteration')
ax6.set_ylabel('Patients Being Treated')
ax6.set_title('Hospital Capacity Utilization')
ax6.legend()
ax6.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

```